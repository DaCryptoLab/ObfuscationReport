\section{Preliminaries}

Here we define all cryptographic primitives that we will use in this report. We will say that a function $f(\lambda)$ is negligible if $f(\lambda)\in o(1/p(\lambda))$ for any polynomial $p$. In this case we will abuse notation and write $f(\lambda)=\negl(\lambda)$.

Two distributions $D_0,D_1$ over a universe $U\in\bit^n$ are called indistinguishable, writing $D_0\compind D_1$, if for any PPT algorithm $A$, it holds that
\[
\left|\Pr_{x\gets D_0}[A(x)=1]-\Pr_{x\gets D_1}[A(x)=1]\right|=\negl(n)
\]

\subsection{Indistinguishability Obfuscation}

Intuitively an indistinguishability obfuscator $\iO$ is an algorithm that takes as input a circuit and outputs an obfuscated circuit that preserves the functionality of the original one. The security definition states that the indistinguishability obfuscations of two functionally equivalent programs are indistinguishable.

\begin{mydef}
A PPT algorithm $\iO$ is an indistinguishability obfuscator for a class of circuits $\cclass$ if it has the following properties:
\begin{itemize}
\item (functionality) For any $C\in\cclass$ and for any input $x$, it holds that
\[
\iO(C)(x)=C(x)
\]
\item (indistinguishability) For any functionally equivalent circuits $C_0,C_1\in\cclass$, it holds that
\[
\iO(C_0,1^\lambda)\compind \iO(C_1,1^\lambda)
\]
where the distributions are over the randomness of $\iO$.
\end{itemize}
\end{mydef}



\subsection{Functional Encryption}
A functional encryption scheme is an encryption scheme where each decryption key is associated to a function. Using this decryption key, we are not able to learn the original message but only the function of this message. In the construction of $\iO$ from $\FE$ we are only interested in a weaker version of $\FE$ where we have only one function $f$ for each public key. Moreover, it is enough assume selective security.
\begin{mydef}
A single key, selectively secure public-key succinct functional encryption scheme $\FE$ for a function class $\fclass$ consists of three PPT algorithms: $\FESetup(f,1^\lambda)\to(pk,sk_f)$, $\FEEnc_{pk}(x)\to c$ and $\FEDec_{sk_f}(c) \to y$ and satisfies the following properties:
\begin{itemize}
\item (correctness) For any $f\in\fclass$, if $(pk,sk_f)\gets\FESetup(f,1^\lambda)$ then
\[
\FEDec_{sk_f}\left(\FEEnc_{pk}(x)\right)=f(x)
\]
\item (selective security): For any $x_0,x_1\in\bit^n$ and $f\in\fclass$ such that $f(x_0)=f(x_1)$, if $(pk,sk_f)\gets\FESetup(f,1^\lambda)$ then
\[
\left(pk,sk_f,\FEEnc_{pk}(x_0)\right)\compind \left(pk,sk_f,\FEEnc_{pk}(x_1)\right)
\]
\item Succinct encryption: the size of the encryption circuit is polynomial in $\lambda,n$. In particular, it does not depend on $\fclass$.
\end{itemize}
\end{mydef}


\subsection{Pseudorandomness}

In our constructions we need to make use of some pseudorandom tools, defined in this section. 

\begin{mydef}
A deterministic function $G:\bit^n\to\bit^{2n}$ is called a length doubling pseudorandom generator if it is efficiently computable and $G(U_n)\compind U_{2n}$.
\end{mydef}

Another important tool which is used in almost any construction involving $\iO$ is that of \emph{puncturable PRFs}. Intuitively, a puncturable PRF $f$ has the property that we can \emph{puncture out} a point $x^*$ from its domain in such a way that $f$ maintains it functionality on all inputs $x\ne x^*$ but it is pseudorandom on $x^*$. It is worth to note that the actual puncturing takes place on the key. In other words, if we want to puncture out $x^*$, we will create a key $k\{x^*\}$ and now $f_{k\{x^*\}}$ will be the puncturable PRF (the definition of $f$ remains the same.)

\begin{mydef}
A class of functions $\{f_k:\bit^n\to\bit^n\}_{k\in\bit^n}$ is called a puncturable PRF if it is efficiently computable and there exist PPT algorithms $\prfgen(1^n)\to k$ and $\prfpunc(x^*)\to k\{x^*\}$ such that
\begin{itemize}
\item (functionality preserving) For any $x\ne x^*$, if $k\gets\prfgen(1^n)$ and $k\{x^*\}\gets\prfpunc(x^*)$ it holds that
\[
f_k(x)=f_{k\{x^*\}}(x)
\]
\item (pseudorandom on the punctured point) For any $x^*$, if $k\gets\prfgen(1^n)$ and $k\{x^*\}\gets\prfpunc(x^*)$ then
\[
\left(x^*,k\{x^*\},f_k(x^*)\right)\compind \left(x^*,k\{x^*\},U\right)
\]
where the distributions are over the randomness of $\prfgen$ and $\prfpunc$.
\end{itemize}
\end{mydef}

In the following we will also make use of a secret-key encryption scheme $(\senc,\sdec)$ which is single message secure; i.e. for any two messages $m_0,m_1$ it holds that $\senc_k(m_0)\compind\senc_k(m_1)$, where $k\gets\bit^n$. 